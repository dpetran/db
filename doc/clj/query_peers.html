<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Query Peers Library</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">com.fluree/db</span> <span class="project-version">1.0.0-rc8</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="overview.html"><div class="inner"><span>FlureeDB Networks</span></div></a></li><li class="depth-1  current"><a href="query_peers.html"><div class="inner"><span>Query Peers Library</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="fluree.db.api.html"><div class="inner"><span>fluree.db.api</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#query-peers-library" name="query-peers-library"></a>Query Peers Library</h1>
<h2><a href="#connecting" name="connecting"></a>Connecting</h2>
<p>Query peers can connect to one or multiple FlureeDB transactor groups, which may be participating in one or more FlureeDB networks (networks are a grouping of databases, sort of like a top level domain name). FlureeDB has the ability to reference subjects across networks, effectively performing joins across databases that are operated completely independently.</p>
<h3><a href="#creating-a-connection-to-a-transactor-group" name="creating-a-connection-to-a-transactor-group"></a>Creating a connection to a transactor group</h3>
<p>The first step in establishing a query peer is to establish a ‘connection’ to your transactor group. Because you may be running multiple transactors in your group, you can provide a list of addresses and the query peer will pick one at random to be its primary. If disconnected, it will re-try a different transactor. Establishing a connection is done as follows, with both the protocol and port being optional (tcp:// and port 9790 are used as defaults):</p>
<pre><code class="clojure">(def conn (fdb/connect "tcp://10.1.1.1:9790,tcp://10.0.0.0:9790,tcp://10.2.2.2:9790"))
</code></pre>
<h3><a href="#creating-a-database-session" name="creating-a-database-session"></a>Creating a database session</h3>
<p>With a connection established, you create a ‘session’ to a specific database served by that network. Sessions are cached internally, so you can create them at-will and do not need to store them centrally. To create a session, you pass it a connection and the name of the database you wish to interact with. A database can be referenced with <code>&lt;network&gt;/&lt;db-name&gt;</code>.</p>
<pre><code class="clojure">(def mydb-sess (fdb/session conn "my_network/mydb"))
</code></pre>
<p>A session will automatically keep the current version of the database up-to-date for you through its communication with the transactor group. Once idle for a period of time, a session will close to save resources. It will automatically re-load the next time you use it.</p>
<p>Sessions are used to access any version of the database (both current and historical), in addition it is used to send transactions (updates) for processing.</p>
<h3><a href="#querying-a-database" name="querying-a-database"></a>Querying a database</h3>
<p>To get the most current known version of the database to query, we request it from the session like:</p>
<pre><code class="clojure">(def mydb (fdb/db mydb-sess))
</code></pre>
<p>Here, <code>mydb</code> is contains an immutable version of the mydb database as of the moment in time you asked for it. It can be passed around your application, and will never, ever, ever, ever (is that clear?) change underneath you. If you had a long-running process and wanted to keep getting the most current version of the database, just ask for it again from the session using <code>fdb/db</code>.</p>
<p>To query <code>mydb</code>:</p>
<pre><code class="clojure">(fdb/query mydb {:select ["*"] :from "_collection"})
</code></pre>
<p>To get a historical version of the database “mydb”, you specify the moment in time either using the ‘block’ number or using a wall clock time with an ISO-8601 string. </p>
<pre><code class="clojure">;; using a block to represent the moment in time:
(def old-mydb (fdb/db mydb-sess 10))
;; using a time string to represent the moment in time:
(def old-mydb (fdb/db mydb-sess "2018-08-28T14:43:21.440Z"))
</code></pre>
<h3><a href="#transacting-on-a-database" name="transacting-on-a-database"></a>Transacting on a database</h3>
<p>Transactions always work against the most recent version of the database and are processed in order. The transactors are the only servers who have the guarantee of the ordering and most recent db version. Therefore, we send all transactions to the transactor group for processing, and they will return a response.</p>
<p>We use the database session to issue transactions and handle this communication for us. Here is a sample transaction:</p>
<pre><code class="clojure">(db/transact mydb-sess [{:_id "person$tempid" :name "John Smith"}])
</code></pre>
<p>Blockchain transactions in reality are not this simple, they require the transaction to be signed using a private key, and possibly other metadata. A private key can be provided when establishing the session which will be used as a default for transactions. If the session does not have a key specified, a default for the original connection, if specified, is passed to each session.</p>
<p>Each individual transaction can also specify a private key, or it can simply relay an already signed transaction that presumably was created in a client somewhere. Regardless of how it happens, by the time a transaction gets to the transactor group, it is signed and locked. The transactor group will only process it if valid.</p></div></div></div></body></html>