<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>fluree.db.api documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">com.fluree/db</span> <span class="project-version">1.0.0-rc8</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="overview.html"><div class="inner"><span>FlureeDB Networks</span></div></a></li><li class="depth-1 "><a href="query_peers.html"><div class="inner"><span>Query Peers Library</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="fluree.db.api.html"><div class="inner"><span>fluree.db.api</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="fluree.db.api.html#var-account-id"><div class="inner"><span>account-id</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-auth-match"><div class="inner"><span>auth-match</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-block-event-.3Emap"><div class="inner"><span>block-event-&gt;map</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-block-query-async"><div class="inner"><span>block-query-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-block-range"><div class="inner"><span>block-range</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-block-range-with-txn-async"><div class="inner"><span>block-range-with-txn-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-close"><div class="inner"><span>close</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-close-listener"><div class="inner"><span>close-listener</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-collection-flakes"><div class="inner"><span>collection-flakes</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-collection-id"><div class="inner"><span>collection-id</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-connect"><div class="inner"><span>connect</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-db"><div class="inner"><span>db</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-delete-ledger"><div class="inner"><span>delete-ledger</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-delete-ledger-async"><div class="inner"><span>delete-ledger-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-flakes"><div class="inner"><span>flakes</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-format-block-resp-pretty"><div class="inner"><span>format-block-resp-pretty</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-format-blocks-resp-pretty"><div class="inner"><span>format-blocks-resp-pretty</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-format-history-resp"><div class="inner"><span>format-history-resp</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-forward-time-travel"><div class="inner"><span>forward-time-travel</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-forward-time-travel-db.3F"><div class="inner"><span>forward-time-travel-db?</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-get-db-at-block"><div class="inner"><span>get-db-at-block</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-get-history-pattern"><div class="inner"><span>get-history-pattern</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-graphql-async"><div class="inner"><span>graphql-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-history-query"><div class="inner"><span>history-query</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-history-query-async"><div class="inner"><span>history-query-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-index"><div class="inner"><span>index</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-latest-block"><div class="inner"><span>latest-block</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-latest-t"><div class="inner"><span>latest-t</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-ledger-info"><div class="inner"><span>ledger-info</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-ledger-info-async"><div class="inner"><span>ledger-info-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-ledger-list"><div class="inner"><span>ledger-list</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-ledger-list-async"><div class="inner"><span>ledger-list-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-ledger-ready.3F"><div class="inner"><span>ledger-ready?</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-ledger-ready.3F-async"><div class="inner"><span>ledger-ready?-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-ledger-stats"><div class="inner"><span>ledger-stats</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-ledger-stats-async"><div class="inner"><span>ledger-stats-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-listen"><div class="inner"><span>listen</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-min-safe"><div class="inner"><span>min-safe</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-monitor-tx-async"><div class="inner"><span>monitor-tx-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-multi-query"><div class="inner"><span>multi-query</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-multi-query-async"><div class="inner"><span>multi-query-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-multi-txns-async"><div class="inner"><span>multi-txns-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-new-ledger"><div class="inner"><span>new-ledger</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-new-ledger-async"><div class="inner"><span>new-ledger-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-new-private-key"><div class="inner"><span>new-private-key</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-predicate-id"><div class="inner"><span>predicate-id</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-predicate-name"><div class="inner"><span>predicate-name</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-public-key"><div class="inner"><span>public-key</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-public-key-from-private"><div class="inner"><span>public-key-from-private</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-query"><div class="inner"><span>query</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-query-async"><div class="inner"><span>query-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-query-with-async"><div class="inner"><span>query-with-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-range"><div class="inner"><span>range</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-resolve-block-range"><div class="inner"><span>resolve-block-range</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-resolve-ledger"><div class="inner"><span>resolve-ledger</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-search"><div class="inner"><span>search</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-search-async"><div class="inner"><span>search-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-session"><div class="inner"><span>session</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-set-default-key-async"><div class="inner"><span>set-default-key-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-sign"><div class="inner"><span>sign</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-sparql-async"><div class="inner"><span>sparql-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-sql-async"><div class="inner"><span>sql-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-subid"><div class="inner"><span>subid</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-subid-async"><div class="inner"><span>subid-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-submit-command-async"><div class="inner"><span>submit-command-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-transact"><div class="inner"><span>transact</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-transact-async"><div class="inner"><span>transact-async</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-tx-.3Ecommand"><div class="inner"><span>tx-&gt;command</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-wait-for-ledger-ready"><div class="inner"><span>wait-for-ledger-ready</span></div></a></li><li class="depth-1"><a href="fluree.db.api.html#var-wait-for-ledger-ready-async"><div class="inner"><span>wait-for-ledger-ready-async</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">fluree.db.api</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-account-id"><h3>account-id</h3><div class="usage"><code>(account-id public-key)</code><code>(account-id message signature)</code></div><div class="doc"><pre class="plaintext">Returns account id from either a public key or message and signature.
</pre></div></div><div class="public anchor" id="var-auth-match"><h3>auth-match</h3><div class="usage"><code>(auth-match auth-set t-map flake)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-block-event-.3Emap"><h3>block-event-&gt;map</h3><div class="usage"><code>(block-event-&gt;map conn ledger block-event)</code></div><div class="doc"><pre class="plaintext">Takes block event data from (listen...) and adds an :added and
:retracted key containing maps of data organized by subject
and containing full predicate names.</pre></div></div><div class="public anchor" id="var-block-query-async"><h3>block-query-async</h3><div class="usage"><code>(block-query-async conn ledger query-map)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-block-range"><h3>block-range</h3><div class="usage"><code>(block-range db start)</code><code>(block-range db start end)</code><code>(block-range db start end opts)</code></div><div class="doc"><pre class="plaintext">Returns a core async channel of blocks from start block (inclusive) to end if provided (exclusive).
Each block is a separate map, containing keys :block, :t and :flakes.
Channel is lazy, continue to take! values as needed.</pre></div></div><div class="public anchor" id="var-block-range-with-txn-async"><h3>block-range-with-txn-async</h3><div class="usage"><code>(block-range-with-txn-async conn ledger block-map)</code></div><div class="doc"><pre class="plaintext">Returns a core async channel of blocks from start block (inclusive) to end if provided (exclusive).
Each block is a separate map, containing keys :block, :t, :flakes and :txn</pre></div></div><div class="public anchor" id="var-close"><h3>close</h3><div class="usage"><code>(close conn)</code></div><div class="doc"><pre class="plaintext">Closes connection.
</pre></div></div><div class="public anchor" id="var-close-listener"><h3>close-listener</h3><div class="usage"><code>(close-listener conn ledger key)</code></div><div class="doc"><pre class="plaintext">Closes a listener.
</pre></div></div><div class="public anchor" id="var-collection-flakes"><h3>collection-flakes</h3><div class="usage"><code>(collection-flakes db collection)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-collection-id"><h3>collection-id</h3><div class="usage"><code>(collection-id db collection)</code></div><div class="doc"><pre class="plaintext">Returns promise containing id of a collection, given a collection name.
Returns nil if collection doesn't exist.</pre></div></div><div class="public anchor" id="var-connect"><h3>connect</h3><div class="usage"><code>(connect ledger-servers &amp; [opts])</code></div><div class="doc"><pre class="plaintext">Connect to a ledger server using URL address. If using a ledger group, multiple addresses can be
supplied, separated by commas.</pre></div></div><div class="public anchor" id="var-db"><h3>db</h3><div class="usage"><code>(db conn ledger)</code><code>(db conn ledger opts)</code></div><div class="doc"><pre class="plaintext">Returns a queryable database from the connection for the specified ledger.
</pre></div></div><div class="public anchor" id="var-delete-ledger"><h3>delete-ledger</h3><div class="usage"><code>(delete-ledger conn ledger)</code><code>(delete-ledger conn ledger opts)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-delete-ledger-async"><h3>delete-ledger-async</h3><div class="usage"><code>(delete-ledger-async conn ledger)</code><code>(delete-ledger-async conn ledger opts)</code></div><div class="doc"><pre class="plaintext">Completely deletes a ledger.
Returns a future that will have a response with a corresponding status of success.

A 200 status indicates the deletion has been successfully initiated.
The full deletion happens in the background on the respective ledger.

Query servers get notified when this process initiates, and ledger will be marked as
being in a deletion state during the deletion process.

Attempts to use a ledger in a deletion state will throw an exception.</pre></div></div><div class="public anchor" id="var-flakes"><h3>flakes</h3><div class="usage"><code>(flakes conn)</code><code>(flakes conn start)</code><code>(flakes conn start end)</code><code>(flakes conn start end {:keys [subject predicate limit offset chunk]})</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of raw flakes from the blockchain history from
start block/transaction (inclusive) to end block/transaction (exclusive).

A nil start defaults to the genesis block. A nil end includes the last block of the known database.
A positive integer for either start/end indicates a block number, a negative integer indicates a
transaction number.

Results can potentially include the entire database depending on your filtering criteria,
so be sure to only 'pull' items as you need them.

The optional map of filter criteria has the following keyed options:

:subject    - Limit results to only include history of this subject, specified as either an _id or identity.
             Note the results are no longer lazy when using this option.
:predicate - Limit results to only include history for this predicate. Must be used in conjunction with subject.
             If there is a need to get history of all subjects for a specific predicate, see 'range-history'.
:limit     - Limit results to this quantity of matching flakes
:offset    - Begin results after this number of matching flakes (for paging - use in conjunction with limit)
:chunk     - Results are fetched in chunks. Optionally specify the size of a chunk if optimization is needed.</pre></div></div><div class="public anchor" id="var-format-block-resp-pretty"><h3>format-block-resp-pretty</h3><div class="usage"><code>(format-block-resp-pretty db curr-block cache fuel)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-format-blocks-resp-pretty"><h3>format-blocks-resp-pretty</h3><div class="usage"><code>(format-blocks-resp-pretty db resp)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-format-history-resp"><h3>format-history-resp</h3><div class="usage"><code>(format-history-resp db resp auth show-auth)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-forward-time-travel"><h3>forward-time-travel</h3><div class="usage"><code>(forward-time-travel db flakes)</code></div><div class="doc"><pre class="plaintext">Returns a core async chan with a new db based on the provided db, including the provided flakes.
Flakes can contain one or more 't's, but should be sequential and start after the current
't' of the provided db. (i.e. if db-t is -14, flakes 't' should be -15, -16, etc.).
Remember 't' is negative and thus should be in descending order.

A forward-time-travel db can be further forward-time-traveled.

A forward-time travel DB is held in memory, and is not shared across servers. Ensure you
have adequate memory to hold the flakes you generate and add. If access is provided via
an external API, do any desired size restrictions or controls within your API endpoint.

Remember schema operations done via forward-time-travel should be done in a 't' prior to
the flakes that end up requiring the schema change.</pre></div></div><div class="public anchor" id="var-forward-time-travel-db.3F"><h3>forward-time-travel-db?</h3><div class="usage"><code>(forward-time-travel-db? db)</code></div><div class="doc"><pre class="plaintext">Returns true if provided db is a forward-time-travel db.
</pre></div></div><div class="public anchor" id="var-get-db-at-block"><h3>get-db-at-block</h3><div class="usage"><code>(get-db-at-block conn ledger block every-n-sec)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-get-history-pattern"><h3>get-history-pattern</h3><div class="usage"><code>(get-history-pattern history)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-graphql-async"><h3>graphql-async</h3><div class="usage"><code>(graphql-async conn db-name query-map)</code></div><div class="doc"><pre class="plaintext">Execute a graphql query against the specified database.
Query must come in as a map with keys:
- query - required graphql string query
- variables - optional substitution variables supplied with query
- opts - optional map of options (same as flureeQL :opts map), however not all options would be relevant for graphql</pre></div></div><div class="public anchor" id="var-history-query"><h3>history-query</h3><div class="usage"><code>(history-query sources query-map)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-history-query-async"><h3>history-query-async</h3><div class="usage"><code>(history-query-async sources query-map)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-index"><h3>index</h3><div class="usage"><code>(index db index start stop)</code></div><div class="doc"><pre class="plaintext">Returns a raw collection of flakes from the specified index as a lazy sequence.

Optionally specify a start and/or stop point to restrict the collection to a range
along with an operator of &lt;, &lt;=, &gt;, &gt;=. If you wish to restrict to a specific
subject, predicate, etc. the = operator can also be used, which is equivalent to the same
parts being specified with a &gt;= and &lt;= operators.

The start and stop point should be specified as a vector of the relevant part(s) of the
specified index. i.e. if using the :spo index, the parts are [s p o], an :pos index would
be [p o s]. If only some parts, i.e. [s] are provided, the other parts are assumed to
be the lowermost or uppermost bounds of the remaining parts depending on if it is the
start or stop respectively. Keep in mind subjects sort descending.

Entities can be specified as an _id long integer, any unique identity (pred / obj two-tuple),
or a collection name.

Predicates can b
</pre></div></div><div class="public anchor" id="var-latest-block"><h3>latest-block</h3><div class="usage"><code>(latest-block conn ledger)</code></div><div class="doc"><pre class="plaintext">Returns latest block (positive integer) for a local ledger. Will bring the ledger locally if not
already local.</pre></div></div><div class="public anchor" id="var-latest-t"><h3>latest-t</h3><div class="usage"><code>(latest-t conn ledger)</code></div><div class="doc"><pre class="plaintext">Returns latest t (negative integer) for a local ledger. Will bring the ledger locally if not
already local.</pre></div></div><div class="public anchor" id="var-ledger-info"><h3>ledger-info</h3><div class="usage"><code>(ledger-info conn ledger)</code></div><div class="doc"><pre class="plaintext">Returns promise with ledger's status as a map, including index, indexes, block, and status.
If ledger doesn't exist, will return an empty map.</pre></div></div><div class="public anchor" id="var-ledger-info-async"><h3>ledger-info-async</h3><div class="usage"><code>(ledger-info-async conn ledger)</code></div><div class="doc"><pre class="plaintext">Returns core async promise channel with ledger's status as a map, including index, indexes, block, and status.
If ledger doesn't exist, will return an empty map.</pre></div></div><div class="public anchor" id="var-ledger-list"><h3>ledger-list</h3><div class="usage"><code>(ledger-list conn)</code></div><div class="doc"><pre class="plaintext">Returns promise with a list of ledgers the connected server is currently serving.
</pre></div></div><div class="public anchor" id="var-ledger-list-async"><h3>ledger-list-async</h3><div class="usage"><code>(ledger-list-async conn)</code></div><div class="doc"><pre class="plaintext">Returns a list of ledgers the connected server is currently serving.
Returns core async promise channel with response.</pre></div></div><div class="public anchor" id="var-ledger-ready.3F"><h3>ledger-ready?</h3><div class="usage"><code>(ledger-ready? conn ledger)</code></div><div class="doc"><pre class="plaintext">Returns true or false if ledger is in a 'ready' status.
</pre></div></div><div class="public anchor" id="var-ledger-ready.3F-async"><h3>ledger-ready?-async</h3><div class="usage"><code>(ledger-ready?-async conn ledger)</code></div><div class="doc"><pre class="plaintext">Returns core async channel that will be true or false if ledger is in a 'ready' status.
</pre></div></div><div class="public anchor" id="var-ledger-stats"><h3>ledger-stats</h3><div class="usage"><code>(ledger-stats conn ledger)</code></div><div class="doc"><pre class="plaintext">Returns promise with ledger info, including db size and # of flakes.
If ledger doesn't exist, will return an empty map.</pre></div></div><div class="public anchor" id="var-ledger-stats-async"><h3>ledger-stats-async</h3><div class="usage"><code>(ledger-stats-async conn ledger)</code></div><div class="doc"><pre class="plaintext">Returns core async promise channel with ledger info, including db size and # of flakes.
If ledger doesn't exist, will return an empty map.</pre></div></div><div class="public anchor" id="var-listen"><h3>listen</h3><div class="usage"><code>(listen conn ledger key fn)</code></div><div class="doc"><pre class="plaintext">Listens to all events of a given ledger. Supply a ledger identity,
any key, and a two-argument function that will be called with each event.

The key is any arbitrary key, and is only used to close the listener via close-listener,
otherwise it is opaque to the listener.

The callback function's first argument is the event header/metadata and the second argument
is the event data itself.</pre></div></div><div class="public anchor" id="var-min-safe"><h3>min-safe</h3><div class="usage"><code>(min-safe &amp; args)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-monitor-tx-async"><h3>monitor-tx-async</h3><div class="usage"><code>(monitor-tx-async conn ledger tid timeout-ms)</code></div><div class="doc"><pre class="plaintext">Monitors a database for a specific transaction id included in a block.

Returns a core async channel that will eventually contain a response,
or will close after the timeout has expired.

Response may contain an exception, if the tx resulted in an exception.</pre></div></div><div class="public anchor" id="var-multi-query"><h3>multi-query</h3><div class="usage"><code>(multi-query sources multi-query-map)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-multi-query-async"><h3>multi-query-async</h3><div class="usage"><code>(multi-query-async sources multi-query-map)</code></div><div class="doc"><pre class="plaintext">Like query, but takes a map of multiple queries - where map keys are any user-provided aliases
and values are queries as if sent directly to 'query'.

If not {:meta true}, any responses with errors will not be returned.

If {:meta true} -&gt;
The response :result contains all provided queries, with keys being the same user-provided aliases
and values being the query results only.

Queries with any non-200 response will not be included in the :result, but will be in a separate
:errors key containing the error(s) using their respective aliases.

If all queries have the identical error status, the overall response status will be that status.
If some queries are 200 status but others have errors, the overall response will be a 207 (WevDAV's multi-status response)
If all queries have error responses, but mixed, the overall response will be 400 unless there is also a 5xx
status code, in which case it will be 500.

Queries leverage multi-threading.

All queries are for the same block. :block can be included on the main map. Whether or not a block
is specified in the main map, any of the individual queries specify a block, it will be ignored. </pre></div></div><div class="public anchor" id="var-multi-txns-async"><h3>multi-txns-async</h3><div class="usage"><code>(multi-txns-async conn ledger txns)</code><code>(multi-txns-async conn ledger txns opts)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-new-ledger"><h3>new-ledger</h3><div class="usage"><code>(new-ledger conn ledger)</code><code>(new-ledger conn ledger opts)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-new-ledger-async"><h3>new-ledger-async</h3><div class="usage"><code>(new-ledger-async conn ledger)</code><code>(new-ledger-async conn ledger opts)</code></div><div class="doc"><pre class="plaintext">Attempts to create new ledger.

A successful result will kick off a process on the ledger server(s) to bootstrap.

Once successful, will return with a command-id.

Ledger creation is handled asynchronously and may not be immediately available.

Options include:
- :alias       - Alias, if different than db-ident.
- :root        - Root account id to bootstrap with (string). Defaults to connection default account id.
- :doc         - Optional doc string about this db.
- :fork        - If forking an existing db, ref to db (actual identity, not db-ident). Must exist in network db.
- :forkBlock   - If fork is provided, optionally provide the block to fork at. Defaults to latest known.
- :persistResp - Respond immediately once persisted with the dbid, don't wait for transaction to be finished
</pre></div></div><div class="public anchor" id="var-new-private-key"><h3>new-private-key</h3><div class="usage"><code>(new-private-key)</code></div><div class="doc"><pre class="plaintext">Generates a new private key, returned in a map along with
the public key and account id. Return keys are :public, :private, and :id.</pre></div></div><div class="public anchor" id="var-predicate-id"><h3>predicate-id</h3><div class="usage"><code>(predicate-id db predicate)</code></div><div class="doc"><pre class="plaintext">Returns promise containing predicate id given a predicate name, or predicate id.
If predicate doesn't exist, returns nil.</pre></div></div><div class="public anchor" id="var-predicate-name"><h3>predicate-name</h3><div class="usage"><code>(predicate-name db predicate-name)</code></div><div class="doc"><pre class="plaintext">Returns promise containing predicate name given predicate id.
</pre></div></div><div class="public anchor" id="var-public-key"><h3>public-key</h3><div class="usage"><code>(public-key message signature)</code></div><div class="doc"><pre class="plaintext">Returns a public key from a message and a signature.
</pre></div></div><div class="public anchor" id="var-public-key-from-private"><h3>public-key-from-private</h3><div class="usage"><code>(public-key-from-private private-key)</code></div><div class="doc"><pre class="plaintext">Returns a public key given a private key.
</pre></div></div><div class="public anchor" id="var-query"><h3>query</h3><div class="usage"><code>(query sources query-map)</code></div><div class="doc"><pre class="plaintext">Execute a query against a database source, or optionally
additional sources if the query spans multiple data sets.
Returns promise with result.</pre></div></div><div class="public anchor" id="var-query-async"><h3>query-async</h3><div class="usage"><code>(query-async sources query-map)</code></div><div class="doc"><pre class="plaintext">Execute a query against a database source, or optionally
additional sources if the query spans multiple data sets.
Returns core async channel containing result.</pre></div></div><div class="public anchor" id="var-query-with-async"><h3>query-with-async</h3><div class="usage"><code>(query-with-async sources param)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-range"><h3>range</h3><div class="usage"><code>(range &amp; args)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of raw flakes for the database and specified index. Results can be
limited by including one or two match clauses, in addition to options including a limit and offset.

Match predicates can be one of: =, &gt;, &gt;=, &lt;, &lt;= as either a string or symbol. If two matches are
provided, one must be a &gt; or &gt;=, and the other a &lt; or &lt;=. An = predicate is only allowed with a single
match statement, and acts the same providing two match statements: &gt;= match &lt;= match]

Matches are a vector containing the flake components desired for a match, in the order dictated
by the specified index. For example, if an spot index is used, the order is [s, p, o]. If an post
index is used, the order is [p, o, s]. The match vector can be a one, two, or three-tuple depending
on the specificity desired for the match. For example, for an spot index where the match should include
all predicates from subject 42, the match clause could be either [42], [42, nil] or [42, nil, nil].
Unlike the 'flakes' function, nil values in a match are only valid if no non-nil value follows.

 Opts may be provided. opts is a map containing any of the optional keys:

 :limit  - Limit results to this quantity
 :history  - Return the history of this range
 :from-block - Only applicable for history, return history up until a certain block
 :chunk  - Results are fetched in chunks. Optionally specify the size of a chunk if optimization is needed.
 :test  - Running as a test. Makes sure, i.e. index ranges are not cached.</pre></div></div><div class="public anchor" id="var-resolve-block-range"><h3>resolve-block-range</h3><div class="usage"><code>(resolve-block-range db query-map)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-resolve-ledger"><h3>resolve-ledger</h3><div class="usage"><code>(resolve-ledger conn ledger)</code></div><div class="doc"><pre class="plaintext">Resolves a ledger identity in the form of 'network/ledger-or-alias' and returns a
two-tuple of [network ledger].

An alias lookup is always performed first, and if an alias doesn't exist it is assumed
the provided name is a ledger id.

If you are providing a ledger id, and wish to skip an alias lookup, a prefix of '$'
can be used for the name portion of the db-ident.

i.e.
- testnet/testledger - Look for ledger with an alias or id of testledger on network testnet.
- testnet/$testledger - look for a ledger with id testledger on network testnet (skip alias lookup).</pre></div></div><div class="public anchor" id="var-search"><h3>search</h3><div class="usage"><code>(search db flake-parts)</code></div><div class="doc"><pre class="plaintext">Returns a promise containing search results of flake parts (fparts).
</pre></div></div><div class="public anchor" id="var-search-async"><h3>search-async</h3><div class="usage"><code>(search-async db flake-parts)</code></div><div class="doc"><pre class="plaintext">Performs a search for matching flakes, returns a core async promise channel.
</pre></div></div><div class="public anchor" id="var-session"><h3>session</h3><div class="usage"><code>(session conn ledger)</code></div><div class="doc"><pre class="plaintext">Returns actual session object for a given ledger.
</pre></div></div><div class="public anchor" id="var-set-default-key-async"><h3>set-default-key-async</h3><div class="usage"><code>(set-default-key-async conn private-key)</code><code>(set-default-key-async conn network private-key)</code><code>(set-default-key-async conn network dbid private-key)</code><code>(set-default-key-async conn network dbid private-key opts)</code></div><div class="doc"><pre class="plaintext">Sets a new default private key for the entire tx-group, network or db level.
This will only succeed if signed by the default private key for the tx-group,
or if setting for a dbid, either the tx-group or network.

It will overwrite any existing default private key.

Returns core async channel that will respond with true or false.</pre></div></div><div class="public anchor" id="var-sign"><h3>sign</h3><div class="usage"><code>(sign message private-key)</code></div><div class="doc"><pre class="plaintext">Returns a signature for a message given provided private key.
</pre></div></div><div class="public anchor" id="var-sparql-async"><h3>sparql-async</h3><div class="usage"><code>(sparql-async db sparql-str)</code><code>(sparql-async db sparql-str opts)</code></div><div class="doc"><pre class="plaintext">Exceute a sparql query against a specified database
</pre></div></div><div class="public anchor" id="var-sql-async"><h3>sql-async</h3><div class="usage"><code>(sql-async db sql-str)</code><code>(sql-async db sql-str opts)</code></div><div class="doc"><pre class="plaintext">Execute an SQL query against a specified database
</pre></div></div><div class="public anchor" id="var-subid"><h3>subid</h3><div class="usage"><code>(subid db ident)</code></div><div class="doc"><pre class="plaintext">Returns promise containing subject id given a subject identity, or subject id.
If subject doesn't exist, returns nil.</pre></div></div><div class="public anchor" id="var-subid-async"><h3>subid-async</h3><div class="usage"><code>(subid-async db ident)</code></div><div class="doc"><pre class="plaintext">Like subid, but returns a core async promise channel instead of a promise.
</pre></div></div><div class="public anchor" id="var-submit-command-async"><h3>submit-command-async</h3><div class="usage"><code>(submit-command-async conn command)</code></div><div class="doc"><pre class="plaintext">Submits a fully signed command to the connected ledger group.
Commands have two required keys:
  - cmd  - a map with the transactional data as a JSON string
  - sig - the signature of the stringified tx map

Command ids are the sha3 of the cmd, and can be used to reference command status
or look them up (i.e. a transaction command id is the txid.)

The stringified cmd contains a payload that is a map, a transaction example follows:

{:type   tx             - command type is required on all commands
 :db     testnet/mydb   - db name, use testnet/$mydb to peg to a dbid
 :tx     [{...}, {...}] - transactional data
 :auth   ABC12345676    - only required if using an authority's signature, else inferred from signature
 :fuel   10000          - max fuel to spend, only required if enforcing fuel limits. tx will fail if auth
                          doesn't have this much fuel avail. Will fail if all fuel is consumed. Unused fuel
                          will not be debited.
 :nonce  1234           - nonce ensures uniqueness, making sure two identical transactions have different txids
 :expire 1547049123614  - don't even attempt this transaction after this moment in time
 :deps   []             - optional one or more txids that must execute successfully before this tx executes
                          if any of the txs in deps fail, this tx will fail
}

Attempting to cancel a transaction
{:type   tx-cancel
 :txid   DSFGFHSDDF  - txid you wish to cancel
}


A new ledger command looks like:
Note new ledgers are issued as a command, and auth/signature should have proper authority on ledger servers.
{:type      new-db          - command type is required on all commands
 :db        testnet/mydb   - db name - as network/dbid
 :alias     testnet/mydb   - optional alias, will default to 'db' if not specified.
 :fork      testnet/forkdb - optional name of db to fork, if forking. Use testnet/$forkdb to peg to a dbid
 :forkBlock 42             - if forking a db, optionally provides a block to fork at, else will default to current block
 :auth      ABC12345676    - only required if using an authority's signature
 :fuel      10000          - max fuel to spend, only required if enforcing fuel limits. tx will fail if auth
                             doesn't have this much fuel avail. Will fail if all fuel is consumed. Unused fuel
                             will not be debited.
 :nonce     1234           - nonce ensures uniqueness, making sure two identical transactions have different txids
 :expire    1547049123614  - don't even attempt this transaction after this moment in time
}
</pre></div></div><div class="public anchor" id="var-transact"><h3>transact</h3><div class="usage"><code>(transact conn ledger txn)</code><code>(transact conn ledger txn opts)</code></div><div class="doc"><pre class="plaintext">Like transact-async, but returns a promise.
</pre></div></div><div class="public anchor" id="var-transact-async"><h3>transact-async</h3><div class="usage"><code>(transact-async conn ledger txn)</code><code>(transact-async conn ledger txn opts)</code></div><div class="doc"><pre class="plaintext">Submits a transaction for a ledger and a transaction. Returns a core async channel
that will eventually have the result of the tx, the txid (if :txid-only option used), or
an exception due to an invalid transaction or if the timeout occurs prior to a response.

Will locally sign a final transaction command if a private key is provided via :private-key
in the options, otherwise will submit the transaction to the connected ledger and request signature,
provided the ledger group has a default private key available for signing.

Options (opts) is a map with the following possible keys:
- private-key - The private key to use for signing. If not present, a default
                private key will attempt to be used from the connection, if available.
- auth        - The auth id for the auth record being used. The private key must
                correspond to this auth record, or an authority of this auth record.
- expire      - When this transaction should expire if not yet attempted.
                Defaults to 5 minutes.
- nonce       - Any long/64-bit integer value that will make this transaction unique.
                By default epoch milliseconds is used.
- deps        - List of one or more txids that must be successfully processed before
                this tx is processed. If any fail, this tx will fail. (not yet implemented)
- txid-only   - Boolean (default of false). If true, will not wait for a response to the tx,
                but instead return with the txid once it is successfully persisted by the
                transactors. The txid can be used to look up/monitor the response at a later time.
- timeout     - will respond with an exception if timeout reached before response available.</pre></div></div><div class="public anchor" id="var-tx-.3Ecommand"><h3>tx-&gt;command</h3><div class="usage"><code>(tx-&gt;command ledger txn private-key)</code><code>(tx-&gt;command ledger txn private-key opts)</code></div><div class="doc"><pre class="plaintext">Helper function to fill out the parts of the transaction that are incomplete,
producing a signed command.

Optional opts is a map with the following keys. If not provided,
defaults will be attempted.
- auth        - The auth id for the auth record being used. The private key must
                correspond to this auth record, or an authority of this auth record.
- expire      - When this transaction should expire if not yet attempted.
                Defaults to 5 minutes.
- nonce       - Any long/64-bit integer value that will make this transaction unique.
                By default epoch milliseconds is used.
- deps        - Not yet implemented, list of dependent transactions.

If successful, will return a map with four keys:
  - cmd  - a map with the command/transaction data as a JSON string
  - sig  - the signature of the above stringified map
  - id   - the ID for this unique request - in case you want to look it up later, sha3 of 'cmd'
  - db   - the ledger for this transaction</pre></div></div><div class="public anchor" id="var-wait-for-ledger-ready"><h3>wait-for-ledger-ready</h3><div class="usage"><code>(wait-for-ledger-ready conn ledger)</code><code>(wait-for-ledger-ready conn ledger timeout)</code></div><div class="doc"><pre class="plaintext">Will block until ledger is in ready status and return true, or
if supplied timeout in milliseconds expires, will return nil.
Defaults timeout to 30000 if two-arity call is used.</pre></div></div><div class="public anchor" id="var-wait-for-ledger-ready-async"><h3>wait-for-ledger-ready-async</h3><div class="usage"><code>(wait-for-ledger-ready-async conn ledger timeout)</code></div><div class="doc"><pre class="plaintext">Returns core async channel that will return true when ledger is in ready status
or if timeout in ms supplied expires, will close the channel (returning nil).</pre></div></div></div></body></html>